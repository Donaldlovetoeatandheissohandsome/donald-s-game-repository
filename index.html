<script>
// åŸºç¤è®Šé‡
let canvas, ctx;
let snake, direction, food;
let score = 0;
let gameOver = false;
let isComputerMode = true; // é»˜èªé›»è…¦æ¨¡å¼
let touchJoystick = { x: 0, y: 0, isPressed: false };

// è›‡ç³§ç”Ÿæˆæ¦‚ç‡ï¼ˆæ ¸å¿ƒï¼šé»˜èª1%ï¼Œå¯†ç¢¼æ­£ç¢ºå¾Œ90%ï¼‰
let foodSpawnRate = 0.01; // 1% æ¦‚ç‡
// å¯†ç¢¼ç›¸é—œè®Šé‡
const SECRET_PASSWORD = "bryananddonald";
let inputPassword = ""; // å­˜å„²ç©å®¶è¼¸å…¥çš„å¯†ç¢¼

// åˆå§‹åŒ–éŠæˆ²
function initGame() {
  canvas = document.getElementById("gameCanvas");
  ctx = canvas.getContext("2d");
  
  // è¨­å‚™é¸æ“‡äº‹ä»¶
  document.getElementById("computerBtn").addEventListener("click", () => {
    isComputerMode = true;
    document.getElementById("modeSelect").style.display = "none";
    resetGame();
  });
  document.getElementById("tabletBtn").addEventListener("click", () => {
    isComputerMode = false;
    document.getElementById("modeSelect").style.display = "none";
    resetGame();
    initJoystick(); // åˆå§‹åŒ–æ–æ¡¿
  });

  // ç›£è½å…¨åŸŸéµç›¤è¼¸å…¥ï¼ˆå¯†ç¢¼è¼¸å…¥ï¼‰
  document.addEventListener("keydown", handleKeyInput);
}

// è™•ç†éµç›¤è¼¸å…¥ï¼ˆç§»å‹•+å¯†ç¢¼ï¼‰
function handleKeyInput(e) {
  // 1. å¯†ç¢¼è¼¸å…¥é‚è¼¯ï¼ˆä¸åˆ†å¤§å°å¯«ï¼‰
  const key = e.key.toLowerCase();
  if (/^[a-z]$/.test(key)) { // åªæ¥æ”¶å­—æ¯
    inputPassword += key;
    // æˆªæ–·å¤šé¤˜å­—ç¬¦ï¼ˆé¿å…å¯†ç¢¼éé•·ï¼‰
    if (inputPassword.length > SECRET_PASSWORD.length) {
      inputPassword = inputPassword.slice(-SECRET_PASSWORD.length);
    }
    // é©—è­‰å¯†ç¢¼
    if (inputPassword === SECRET_PASSWORD) {
      foodSpawnRate = 0.9; // æ”¹ç‚º90%æ¦‚ç‡
      inputPassword = ""; // é‡ç½®è¼¸å…¥
      alert("å¯†ç¢¼æ­£ç¢ºï¼è›‡ç³§ç”Ÿæˆæ¦‚ç‡æå‡è‡³90%ğŸ‰");
    }
  }

  // 2. è›‡ç§»å‹•æ§åˆ¶ï¼ˆé›»è…¦æ¨¡å¼ï¼‰
  if (isComputerMode && !gameOver) {
    switch(e.key) {
      case "ArrowUp":
      case "w":
      case "W":
        if (direction !== "down") direction = "up";
        break;
      case "ArrowDown":
      case "s":
      case "S":
        if (direction !== "up") direction = "down";
        break;
      case "ArrowLeft":
      case "a":
      case "A":
        if (direction !== "right") direction = "left";
        break;
      case "ArrowRight":
      case "d":
      case "D":
        if (direction !== "left") direction = "right";
        break;
      case " ": // ç©ºæ ¼é‡å•ŸéŠæˆ²
        if (gameOver) resetGame();
        break;
    }
  }
}

// åˆå§‹åŒ–æ–æ¡¿ï¼ˆå¹³æ¿æ¨¡å¼ï¼‰
function initJoystick() {
  const joystick = document.getElementById("joystick");
  const stick = document.getElementById("stick");
  
  joystick.style.display = "block";
  let rect = joystick.getBoundingClientRect();
  const joystickSize = rect.width / 2;

  // è§¸æ‘¸äº‹ä»¶
  joystick.addEventListener("touchstart", (e) => {
    touchJoystick.isPressed = true;
    updateJoystick(e.touches[0]);
  });
  document.addEventListener("touchmove", (e) => {
    if (touchJoystick.isPressed) updateJoystick(e.touches[0]);
  });
  document.addEventListener("touchend", () => {
    touchJoystick.isPressed = false;
    touchJoystick.x = 0;
    touchJoystick.y = 0;
    stick.style.transform = "translate(0,0)";
  });

  // æ›´æ–°æ–æ¡¿ä½ç½®å’Œæ–¹å‘
  function updateJoystick(touch) {
    const x = touch.clientX - rect.left - joystickSize;
    const y = touch.clientY - rect.top - joystickSize;
    const distance = Math.sqrt(x*x + y*y);
    
    // é™åˆ¶æ–æ¡¿ç¯„åœ
    if (distance > joystickSize) {
      touchJoystick.x = (x / distance) * joystickSize;
      touchJoystick.y = (y / distance) * joystickSize;
    } else {
      touchJoystick.x = x;
      touchJoystick.y = y;
    }
    
    // ç§»å‹•æ–æ¡¿è¦–è¦º
    stick.style.transform = `translate(${touchJoystick.x}px, ${touchJoystick.y}px)`;
    
    // åˆ¤æ–·æ–¹å‘
    if (Math.abs(touchJoystick.y) > Math.abs(touchJoystick.x)) {
      direction = touchJoystick.y < 0 ? "up" : "down";
    } else {
      direction = touchJoystick.x > 0 ? "right" : "left";
    }
  }
}

// é‡ç½®éŠæˆ²
function resetGame() {
  snake = [
    { x: 10, y: 10 },
    { x: 9, y: 10 },
    { x: 8, y: 10 }
  ];
  direction = "right";
  score = 0;
  gameOver = false;
  spawnFood(); // ç”Ÿæˆåˆå§‹è›‡ç³§
  gameLoop();
}

// ç”Ÿæˆè›‡ç³§ï¼ˆåŸºæ–¼æ¦‚ç‡ï¼‰
function spawnFood() {
  // éš¨æ©Ÿåˆ¤æ–·æ˜¯å¦ç”Ÿæˆè›‡ç³§ï¼ˆé»˜èª1%ï¼Œå¯†ç¢¼æ­£ç¢ºå¾Œ90%ï¼‰
  if (Math.random() > foodSpawnRate) {
    food = null; // ä¸ç”Ÿæˆ
    return;
  }

  // éš¨æ©Ÿç”Ÿæˆè›‡ç³§ä½ç½®ï¼ˆé¿é–‹è›‡èº«ï¼‰
  do {
    food = {
      x: Math.floor(Math.random() * canvas.width / 20),
      y: Math.floor(Math.random() * canvas.height / 20),
      type: getRandomFoodType() // éš¨æ©Ÿè›‡ç³§é¡å‹
    };
  } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
}

// éš¨æ©Ÿè›‡ç³§é¡å‹
function getRandomFoodType() {
  const types = ["apple", "blueberry", "strawberry", "colorful"];
  const weights = [0.6, 0.2, 0.15, 0.05]; // åŠ æ¬Šæ¦‚ç‡
  let random = Math.random();
  let sum = 0;
  
  for (let i = 0; i < types.length; i++) {
    sum += weights[i];
    if (random <= sum) return types[i];
  }
  return "apple";
}

// ç¹ªè£½éŠæˆ²
function drawGame() {
  // æ¸…ç©ºç•«å¸ƒ
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (gameOver) {
    ctx.fillStyle = "#ff0000";
    ctx.font = "30px Arial";
    ctx.textAlign = "center";
    ctx.fillText("éŠæˆ²çµæŸï¼åˆ†æ•¸ï¼š" + score, canvas.width/2, canvas.height/2);
    ctx.fillText("æŒ‰ç©ºæ ¼é‡å•Ÿ", canvas.width/2, canvas.height/2 + 40);
    return;
  }

  // ç¹ªè£½è›‡
  snake.forEach((segment, index) => {
    // è®Šè‰²è›‡ç³§æ•ˆæœï¼šè›‡èº«é¡è‰²éš¨æ©Ÿ
    if (food && food.type === "colorful" && index === 0) {
      ctx.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
    } else {
      ctx.fillStyle = index === 0 ? "#00ff00" : "#008000";
    }
    ctx.fillRect(segment.x * 20, segment.y * 20, 18, 18);
  });

  // ç¹ªè£½è›‡ç³§
  if (food) {
    switch(food.type) {
      case "apple": ctx.fillStyle = "#ff0000"; break;
      case "blueberry": ctx.fillStyle = "#0000ff"; break;
      case "strawberry": ctx.fillStyle = "#ff69b4"; break;
      case "colorful": ctx.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`; break;
    }
    ctx.fillRect(food.x * 20, food.y * 20, 18, 18);
  }

  // ç¹ªè£½åˆ†æ•¸
  ctx.fillStyle = "#fff";
  ctx.font = "20px Arial";
  ctx.fillText("åˆ†æ•¸ï¼š" + score, 10, 30);
  // é¡¯ç¤ºç•¶å‰è›‡ç³§æ¦‚ç‡
  ctx.fillText(`è›‡ç³§æ¦‚ç‡ï¼š${Math.round(foodSpawnRate * 100)}%`, canvas.width - 120, 30);
}

// éŠæˆ²é‚è¼¯æ›´æ–°
function updateGame() {
  if (gameOver) return;

  // ç§»å‹•è›‡é ­
  const head = { ...snake[0] };
  switch(direction) {
    case "up": head.y--; break;
    case "down": head.y++; break;
    case "left": head.x--; break;
    case "right": head.x++; break;
  }

  // ç¢°æ’æª¢æ¸¬ï¼ˆé‚Šç•Œï¼‰
  if (
    head.x < 0 || head.x >= canvas.width / 20 ||
    head.y < 0 || head.y >= canvas.height / 20 ||
    snake.some(segment => segment.x === head.x && segment.y === head.y)
  ) {
    gameOver = true;
    return;
  }

  snake.unshift(head);

  // åƒè›‡ç³§åŠ åˆ†
  if (food && head.x === food.x && head.y === food.y) {
    // ä¸åŒè›‡ç³§åŠ åˆ†è¦å‰‡
    switch(food.type) {
      case "apple": score += 10; break;
      case "blueberry": score += 20; break;
      case "strawberry": score += 25; break;
      case "colorful": score += 50; break;
    }
    spawnFood(); // ç”Ÿæˆæ–°è›‡ç³§
  } else {
    snake.pop(); // æ²’åƒå°±ç¸®å°¾
  }
}

// éŠæˆ²ä¸»å¾ªç’°
function gameLoop() {
  updateGame();
  drawGame();
  if (!gameOver) requestAnimationFrame(gameLoop);
}

// é é¢åŠ è¼‰å¾Œåˆå§‹åŒ–
window.onload = initGame;

// Chrome å…¼å®¹æ€§ä¿®å¾©
document.addEventListener('touchstart', function(e) {}, { passive: false });
document.addEventListener('touchmove', function(e) {}, { passive: false });
</script>
